---
title: "Get started"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Get started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  eval = TRUE,
  echo = TRUE,
  collapse = TRUE,
  comment = "#>"
)
```

This article shows some of the key features of __fgeo__ applied to an exploratory data analysis. For a deeper and general approach to exploratory data analysis, see [this book section](http://r4ds.had.co.nz/exploratory-data-analysis.html). A version adapted for ForestGEO is available [here](https://forestgeo.github.io/fgeo/articles/siteonly/eda.html).

## Packages 

In every new R session you need to "open" __fgeo__ with `library`().

```{r}
library(fgeo.data)
library(fgeo)
```

## Data

You may load your own data. Here we will use data from the __fgeo.data__ package -- which comes with __fgeo__.

```R
fgeo_help("datasets")
```

We will use a dataset of stems censused in one hectare from the forest plot in Luquillo, Puerto Rico (https://forestgeo.si.edu/sites/north-america/luquillo).

```{r}
stem <- luquillo_stem_random
str(stem)
```

For a description of the columns, see `?data_dictionary`.

```{r}
str(data_dictionary)

cols <- names(stem)
filter(data_dictionary, column %in% cols)
```

This dataset comes with multiple censuses. We will pick only the latest one.

```{r}
unique(stem$CensusID)

# `pick_top()` with n < 0 from the bottom rank of `var`. See ?pick_top().
stem6 <- pick_top(stem, var = CensusID, n = -1)
unique(stem6$CensusID)
```

## Demography

```{r}
census5 <- fgeo.data::luquillo_tree5_random
census6 <- fgeo.data::luquillo_tree6_random

recruitment_ctfs(census5, census6)
```

With `to_df()` we convert the result of any demography function to a tibble -- a convenient dataframe.

```{r}
to_df(
  recruitment_ctfs(census5, census6)
)
```

We can aggregate results by any number of variables:

* To aggregate by a single variable, you can pass the variable directly to `split1`.

```{r}
to_df(recruitment_ctfs(census5, census6, split1 = census5$sp))
```

* To aggregate by multiple variables, use `interaction()` (but aggregating by more than one variable may be slow and confusing).

```{r}
sp_quadrat <- interaction(census5$sp, census5$quadrat)
by_many <- recruitment_ctfs(census5, census6, split1 = sp_quadrat)
to_df(by_many)
```

To separate the multiple groups we can use `tidyr::separate()`.

```{r}
tidyr::separate(to_df(by_many), groups, into = c("species", "quadrats"))
```

The same works for mortality and growth.

```{r}
to_df(mortality_ctfs(census5, census6, split1 = sp_quadrat))

to_df(growth_ctfs(census5, census6, split1 = sp_quadrat))
```

## Exploring the distribution of status and tree diameter

Two columns that are commonly useful in ForestGEO datasets are `status` and `dbh` (diameter at breast height). We will begin by better understanding what type of variables they are. For this, base R provides useful functions.

`status` is a categorical variable. 

```{r}
summary(stem6$status)
```

We can count the number of observations in each category with `table()`, then visualize the result with `barplot()`.

```{r}
by_category <- table(stem6$status)
barplot(by_category)
```

`dbh` is a continuous numeric variable.

```{r}
summary(stem6$dbh)
```

(Note the missing values (`NA`s).)

And we can visualize its distribution with `hist()`. 

```{r}
hist(stem6$dbh)
```

Unfortunately `hist()` dropped missing values silently. But we can better understand how missing values of `dbh` relate to `status` by extracting only the columns `dbh` and `status`, and picking only the rows where `dbh` is missing.

```{r}
dbh_status <- stem6[c("dbh", "status")]
missing <- filter(dbh_status, is.na(dbh))
unique(missing)
```

Another approach is to count missing values.

```{r}
missing <- transform(stem6, na = ifelse(is.na(dbh), TRUE, FALSE))
table(missing$na, missing$status)
```

We learn that `dbh` is missing where a tree is dead (`status = D`) or gone (`status = G`). This makes sense and, depending on the type of analysis we want to do, we may want to keep or remove missing values.

## Determining tree status based on stem status

Now we are ready to clean the data. For example, we can pick trees which status is "A" (alive). At ForestGEO, working with `status` is so common that __fgeo__ provides a specialized function.

```R
fgeo_help("status")
```

In `stem6`, the variable `status` records the status of each individual stem. How can we determine the status of a tree based on the status of each of its stems? That is the job of `add_status_tree()`.

```{r}
stem6 <- add_status_tree(stem6, status_a = "A", status_d = "D")
alive_trees <- filter(stem6, status_tree == "A")

# Note that alive trees may have some missing, gone or dead stems
some_cols <- c( "treeID", "status_tree", "stemID", "status")
example_tree <- 46
example_rows <- filter(alive_trees, treeID == example_tree)
select(example_rows, some_cols)
```

## Picking a `dbh` range

Another very common task when working with ForestGEO data is to pick stems of a particular `dbh` range.

```R
fgeo_help("dbh")
```

Pick stems of 10 mm or more.

```{r}
ten_plus <- pick_dbh_min(alive_trees, 10)
range(ten_plus$dbh, na.rm = TRUE)
```

## Calculating abundance

Calculate the total abundance of stems and trees.

```{r}
# Drop missing values of `dbh`
non_missing <- filter(ten_plus, !is.na(dbh))

# Stem abundance
abundance(non_missing)

# Tree abundance (picking main stems -- with highest `hom` and largest `dbh`)
main_stems <- pick_main_stem(non_missing)
abundance(main_stems)
```

Calculate the abundance of trees by species.

```{r}
by_sp <- group_by(main_stems, sp)
n_by_sp <- abundance(by_sp)
n_by_sp
```

## Picking the most abundant species

What are the three most abundant tree species?

```{r}
top3 <- pick_top(n_by_sp, n, -3)
top3
```

Now we can pick the `alive_trees` of only the `top3` species.

```{r}
picked_stems <- filter(alive_trees, sp %in% top3$sp)
```

## Mapping the distribution of tree species

__fgeo__ includes some functions specialized in mapping ForestGEO's data.

```R
fgeo_help("map")
```

Map the most abundant species.

```{r}
# luquillo_elevation comes with fgeo
species_elevation <- sp_elev(picked_stems, luquillo_elevation)
autoplot(species_elevation)
```

Tweak to focus on the hectare available in the data.

```{r}
autoplot(species_elevation, xlim = c(100, 200), ylim = c(400, 500))
```



## Species-habitat associations

```{r}
tree <- fgeo.data::luquillo_tree5_random
elevation <- fgeo.data::luquillo_elevation

# Pick alive trees, of 10 mm or more
census <- filter(tree, status == "A", dbh >= 10)

# Pick sufficiently abundant species
pick <- filter(add_count(census, sp), n > 50)
species <- unique(pick$sp)

# Use your habitat data or create it from elevation data
habitat <- fgeo_habitat(elevation, gridsize = 20, n = 4)

# A list or matrices
tt_lst <- tt_test(census, species, habitat)
tt_lst

# A simple summary to help you interpret the results
summary(tt_lst)

# A combined matrix
Reduce(rbind, tt_lst)

# A dataframe
to_df(tt_lst)
```
